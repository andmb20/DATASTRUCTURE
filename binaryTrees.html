<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="This repository is dedicated to studying binary trees data structures, exploring their principles, operations, and practical applications in programming.">
    <title>√Årvores Bin√°rias (Binary Trees)</title>
    <script src="binaryTrees.js"></script>
</head>

<body>
    <a href="index.html">Voltar</a>
    <br><br>
    <h1>√Årvores Bin√°rias (Binary Trees)</h1>
    <p><i>"√Årvore bin√°ria √© como uma √°rvore geneal√≥gica onde cada pessoa tem no m√°ximo dois filhos!"üëßüë¶</i></p>
    <p style="font-size: 20px;">Uma <b>√°rvore bin√°ria</b> √© uma estrutura de dados hier√°rquica onde cada n√≥ possui: um <b>valor (dado)</b> e at√© dois <b>filhos</b> (esquerda e direita). Ideal para representar hierarquias e realizar buscas eficientes.</p>

    <ol>
        <h2>Caracter√≠sticas Principais</h2>
        <li><b>Raiz (Root)</b>: N√≥ superior da √°rvore (√∫nico).</li>
        <li><b>Folhas (Leaves)</b>: N√≥s sem filhos.</li>
        <li><b>Altura (Height)</b>: N√∫mero de n√≠veis da raiz at√© a folha mais distante.</li>
        <li><b>Tipos Especiais</b>:</li>
        <ul>
            <li><b>√Årvore Bin√°ria de Busca (BST)</b>: Valores √† esquerda ‚â§ pai ‚â§ valores √† direita.</li>
            <li><b>√Årvore Balanceada</b>: Altura das sub√°rvores difere em no m√°ximo 1 (ex.: AVL, Red-Black).</li>
        </ul>

    </ol>

    <section>
        <h2>Exemplos em Diferentes Linguagens</h2>
        <code>// JavaScript<br>
            class Node {<br>
                constructor(value) {<br>
                    this.value = value;<br>
                    this.left = null;<br>
                    this.right = null;<br>
                }<br>
            }<br>
            const root = new Node(10);<br>
            root.left = new Node(5);<br>
            root.right = new Node(15);<br>
        </code><br><br>

        <code># Python<br>
            class Node:<br>
                def __init__(self, value):<br>
                    self.value = value<br>
                    self.left = None<br>
                    self.right = None<br>
            root = Node(10)<br>
            root.left = Node(5)<br>
            root.right = Node(15)<br>
        </code><br><br>
    </section>

    <h2>Complexidade das Opera√ß√µes</h2>
    <table border="1">
        <thead>
            <tr>
                <th>Opera√ß√£o</th>
                <th>BST Balanceada</th>
                <th>BST Desbalanceada</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Busca</td>
                <td>O(log n)</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>Inser√ß√£o</td>
                <td>O(log n)</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>Remo√ß√£o</td>
                <td>O(log n)</td>
                <td>O(n)</td>
            </tr>
            <tr>
                <td>Travessia</td>
                <td>O(n)</td>
                <td>O(n)</td>
            </tr>
        </tbody>
    </table>
    <p><i>(A complexidade depende do balanceamento da √°rvore.)</i></p>

    <ul>
        <h2>Quando Usar √Årvores Bin√°rias?</h2>
        <h3>Casos Ideais:</h3>
        <li><b>Busca eficiente</b>: Em BSTs, busca em O(log n) (se balanceada).</li>
        <li><b>Hierarquias</b>: Sistemas de arquivos, organogramas.</li>
        <li><b>Express√µes matem√°ticas</b>: √Årvores de sintaxe.</li>
        <li><b>Algoritmos de compress√£o</b>: Huffman coding.</li>
    </ul>



    <ol>
        <h2>Dicas de Uso Avan√ßado</h2>
        <li><b>Balanceamento Autom√°tico</b>: Use AVL ou Red-Black Trees para manter O(log n).</li>
        <li><b>Travessias:</b></li>
        <ul>
            <li><code>Pr√©-ordem (DFS): Raiz ‚Üí Esquerda ‚Üí Direita (√∫til para copiar √°rvores).</code></li>
            <li><code>Em-ordem (DFS): Esquerda ‚Üí Raiz ‚Üí Direita (retorna valores ordenados em BSTs).</code></li>
            <li><code>P√≥s-ordem (DFS): Esquerda ‚Üí Direita ‚Üí Raiz (√∫til para deletar √°rvores).</code></li>
            <li><code>N√≠vel a n√≠vel (BFS): Usa fila (√∫til para buscar a altura).</code></li>
        </ul>
        <li><b>BST Iterativa</b>: Evite recurs√£o para evitar estouro de pilha em √°rvores muito profundas.</li>
    </ol>

    <ul>
        <h2>Analogia Pr√°tica</h2>
        <h3>Pense em um quiz de "sim ou n√£o":</h3>

        <li>Cada pergunta (n√≥) tem duas respostas poss√≠veis (esquerda = <b>n√£o</b>, direita = <b>sim</b>). O caminho at√© a resposta final √© como percorrer a √°rvore!</li>
    </ul>
    <ul>
        <h3>Quando N√ÉO Usar:</h3>
        <li>Dados <b>n√£o hier√°rquicos</b> ou <b>sequenciais</b> (use listas/arrays).</li>
        <li>Se a √°rvore ficar <b>desbalanceada</b> (pode degenerar para O(n)).</li>
    </ul>

    <h2>Dica Importante</h2>
    <p style="font-size: 20px;"><b>SEMPRE</b> verifique se a √°rvore est√° balanceada ap√≥s inser√ß√µes/remo√ß√µes frequentes. Caso contr√°rio, degrade para O(n)!</p>
</body>

</html>